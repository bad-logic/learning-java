QUESTION 1:
1. @Repository
2. Parameter versioning
3. Pointcut
4. true

QUESTION 2:
1. Autowiring is a form of dependency injection. In spring it refers to the automatic injection of dependencies by
    IOC container.
    Different modes include constructor based, setter based and field based Autowiring.
2.
    Stateless: The server does not store any client context between requests. This stateless nature makes api designs
    isolated thus improving scalability and reliability.
    Uniform Interface: The uniform interface defines a standardized way for clients to interact with resources, making
    the APIs predictable and easier to understand.

QUESTION 3:
Part 1.

@Entity
class Student{
     @Id
     @GeneratedValue(strategy = GenerationType.UUID)
     private UUID student_id;

     private String name;
     private double gpa;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name="address_id")
     private Address address;

     @ManyToMany(fetch = FetchType.LAZY)
     @JoinTable(
       name = "Student_Course",
       joinColumns = @JoinColumn(name = "student_id"),
       inverseJoinColumns = @JoinColumn(name = "course_id"))
      List<Course> courses;

      public List<Course> getCourses(){
        return this.courses;
      }

}

@Entity
class Address{
     @Id
     @GeneratedValue(strategy = GenerationType.UUID)
     private UUID address_id;

     private String city;
     private String state;
     private int zipcode;

     @OneToMany(mappedBy="address")
      private Student student;
}

@Entity
class Course{
     @Id
     private int course_id;

     private String name;

     @ManyToMany(mappedBy="courses")
     List<Student> students;

     @OneToOne(cascade = CascadeType.ALL, mappedBy="course")
     private CourseDetails details;
}

@Entity
class CourseDetails{
     @Id
     @GeneratedValue(strategy = GenerationType.UUID)
     private UUID description_id;

     private String course_description;
     private int credit;
     private String program;

     @UpdateTimestamp
     private Instant last_updated;

     @OneToOne
     @JoinColumn(name="course_id")
     private Course course;
}

Part 2.

@Repository
public interface StudentRepository extends JpaRepository<Student, UUID> {
     @Query("select s from Student s where gpa <= :gpa")
     public List<Student> getStudentWithGpaLessOrEqualTo(gpa);

     @Query("select s from Student s where s.courses.details.program=:program and s.gpa<:gpa")
     public List<Student> searchStudentWithAtLeastOneCourseFromProgramAndGpaLessThan(String program, int gpa);
}

@Repository
public interface AddressRepository extends JpaRepository<Address, UUID> {}

@Repository
public interface CourseRepository extends JpaRepository<Course, int> {}

@Repository
public interface CourseDetailsRepository extends JpaRepository<CourseDetails, UUID> {}

@Service
public class StudentService{
    private StudentRepository studentRespository;

    @Autowired
    StudentService(StudentRepository studentRespository) {
        this.studentRespository = studentRespository;
    }

    public List<Student> findAll(){
        return this.studentRepository.findAll();
    }

    public void save(Student student){
        this.studentRepository.save(student);
    }

    public void update(Student student){
        this.studentRepository.save(student);
    }

    public Student findById(UUID id){
        Optional<Student> stud = this.studentRepository.findById(id);
        return stud.orElse(null);
    }

    public void deleteById(UUID id){
        this.studentRepository.deleteById(id);
    }

    public List<Course> getStudentCourses(UUID id){
        Optional<Student> stud = this.studentRepository.findById(id);
        return stud.getCourses().orElse(null);
    }

    public List<Student> getStudentWithGpaLessOrEqualTo(int gpa){
        return this.studentRepository.getStudentWithGpaLessOrEqualTo(gpa);
    }

    public List<Student> searchStudentWithAtLeastOneCourseFromProgramAndGpaLessThan(String program, int gpa){
        return this.studentRepository.searchStudentWithAtLeastOneCourseFromProgramAndGpaLessThan(program,gpa);
    }
}

@RestController("/students")
class StudentController{
    private StudentService studentService;

    @Autowired
    StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping("")
    public ResponseEntity<Map<String, Object>> getAll() {
        Map<String, Object> response = new HashMap<>();
        response.put("data", this.studentService.findAll().stream().map(StudentMapper::toStudentDTO).collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/with-gpa-equal-or-equal-to")
    public ResponseEntity<Map<String, Object>> getStudentWithGpaLessOrEqualTo(@RequestParam(defaultValue = "1") int gpa) {
        Map<String, Object> response = new HashMap<>();
        response.put("data", this.studentService.getStudentWithGpaLessOrEqualTo(gpa).stream().map(StudentMapper::toStudentDTO).collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/search")
    public ResponseEntity<Map<String, Object>> searchStudentWithAtLeastOneCourseFromProgramAndGpaLessThan(@RequestParam(defaultValue = "MSC") String program, @RequestParam(defaultValue = "1") int gpa) {
        Map<String, Object> response = new HashMap<>();
        response.put("data", this.studentService.searchStudentWithAtLeastOneCourseFromProgramAndGpaLessThan(program,gpa).stream().map(StudentMapper::toStudentDTO).collect(Collectors.toList());
        return ResponseEntity.ok(response);
    }

    @PostMapping("")
    public ResponseEntity<Map<String, Object>> saveStudent(@Valid @RequestBody CreateStudentDTO st) {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "POST successful");
        response.put("data", StudentMapper.toStudentDTO(this.studentService.save(StudentMapper.toEntity(st))));
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PatchMapping("/{id}")
    public ResponseEntity<Map<String, Object>> updateStudent(@PathVariable @NonNull UUID id, @Valid @RequestBody UpdateStudentDTO st) {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "POST successful");
        response.put("data", StudentMapper.toStudentDTO(this.postService.update(StudentMapper.toEntity(st))));
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Map<String, Object>> getSingleStudent(@PathVariable @NonNull UUID id) {
        Map<String, Object> response = new HashMap<>();
        response.put("data", StudentMapper.toStudentDTO(this.studentService.findById(id)));
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}/courses")
    public ResponseEntity<Map<String, Object>> getSingleStudent(@PathVariable @NonNull UUID id) {
        Map<String, Object> response = new HashMap<>();
        response.put("data", this.studentService.getStudentCourses(id).stream().map(CourseMapper::toCourseDTO).collect(Collectors.toList()));
        return ResponseEntity.ok(response);
    }


    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, Object>> deleteSingleStudent(@PathVariable @NonNull UUID id) {
        Map<String, Object> response = new HashMap<>();
        response.put("message", "DELETE successful");
        response.put("data", id);
        return ResponseEntity.ok(response);
    }
}

Part 3

@Aspect
@Component
public class StudentAspect {

   @Pointcut("execution(* StudentController.*(..))")
   private void anyMethodReturningList() {}

   @AfterReturning(pointcut = "anyMethodReturningList()", returning = "result")
   public void sendAlert(JoinPoint joinPoint, Object result) {
       if (result instanceof List<?>) {
           List<?> list = (List<?>) result;
           if (!list.isEmpty() && list.get(0) instanceof Student) {
              sendAlert(joinPoint);
           }
       }
   }

   public void sendAlert( Jointpoint joinpoint ){
    // implementation to send alert
   }
}
