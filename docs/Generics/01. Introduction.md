## Generics


- Prior to jdk 5, collection of any type consisted of collection of objects and downcasting was necessary to retrieve the element of correct type
```java
class Main{
    public static void main(String[] args){
        List words = new ArrayList();
        words.add("Hello");
        words.add(" world!");
        String s = ((String)words.get(0)) + ((String)words.get(1));
        System.out.print(s);
    }
}
```
- In jdk 5, generic parameters were added to the declaration of collection classes, so the above code can be rewritten as
```java
class Main{
    public static void main(String[] args){
        List<String> words = new ArrayList();
        words.add("Hello");
        words.add(" world!");
        String s = words.get(0) + words.get(1);
        System.out.print(s);
    }
}
```

### Benefits

- Stronger type checks at compile time.
- No downcasting
- Reusable code for different data types

### Type Erasure

- Generics are implemented using Type Erasure approach where the compiler uses the generic type information to compile the code, but erases it afterwards.
- Generic information is not available at runtime. This enables generic code to be backward compatible with the legacy code that uses raw types.
- Once the compiler confirms that the generic type is used safely, it converts generic type to raw type.

### Limitations

- Generic Subtyping is not covariant.
    > Manager is a subclass of Employee but ArrayList<Manager> is not subclass of ArrayList<Employee>

- Array Subtyping is covariant.
    > Manager is a subclass of Employee and Manager[] is subclass of Employee[] 

  - Component type of an array is not allowed to be a type variable.
    ```java
    class Main{
        public static void main(String[] args){
            T[] arr = null; // ok 
            arr = new T[5]; // compiler error
            T[] arr = (T[]) new Object[5]; // No Error
        }
    }
    ```

- Component type of an array is not allowed to be a parametrized type.
  ```java
  
        class Pair<T> {
          private T k;
          private T v;
      
          Pair(T k, T v) {
              this.k = k;
              this.v = v;
          }
      
          public T getK() {
              return k;
          }
      
          public T getV() {
              return v;
          }
      
          @Override
          public String toString() {
              return "Pair{" +
                      "k=" + k +
                      ", v=" + v +
                      '}';
          }
      }
    
    class Main{
      public static void main(String[] args){
        List<String>[] lst = new ArrayList<String>[5]; // compiler error
        Pair<Integer>[] a = new Pair<Integer>[10]; // compiler error
  
        List<String>[] lst = new ArrayList[5]; // ok
        Pair<Integer>[] a = new Pair[10]; // ok
        lst[0] = new ArrayList<>(){
                  {
                      add("hello");
                  }
              };
      
              lst[1] = new ArrayList<>(){
                  {
                      add("there");
                      add("hey");
                  }
        };
        
        a[0] = new Pair<Integer>(1,2);
        a[1] = new Pair<Integer>(2,4);
        
        System.out.println(Arrays.toString(lst));
        System.out.println(Arrays.toString(a));
      }
    }
  ```
  > here, new `new ArrayList<String>[5]` is not allowed because Java does not allow the creation of arrays with a parameterized component type
  > however, `new ArrayList[5]` creates an array of the raw type ArrayList and raw type effectively disables generic type checking. thus this is allowed with unchecked warning.

- 